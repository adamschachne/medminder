#!/usr/bin/env node

const webpush = require('web-push');
const moment = require('moment');
const { Client } = require('pg');
const connection = new Client({
  connectionString: process.env.DATABASE_URL,
  ssl: true
});
const knex = require('knex')({
  client: 'pg',
  connection: {
    host: connection.host,
    port: connection.port,
    user: connection.user,
    password: connection.password,
    database: connection.database,
    ssl: true
  }
  //connection: process.env.DATABASE_URL
});

const vapidKeys = {
  publicKey : process.env.VAPID_PUBLIC_KEY,
  privateKey : process.env.VAPID_PRIVATE_KEY
}

webpush.setGCMAPIKey(process.env.FCM_SERVER_KEY);
webpush.setVapidDetails(
  'mailto:'+process.env.CONTACT_EMAIL,
  vapidKeys.publicKey,
  vapidKeys.privateKey
);

var nowMoment = moment();
var buffer = 0.1; // ~6 minutes plus or minus
var currentTimeString = nowMoment.format("dddd, MMMM Do YYYY, h:mm:ss a");

knex.select('*')
.from('medications')
.whereNull('deleted')
.andWhere('active', '=', true)
.asCallback(function(err, rows) {
  if (err) console.log(err)

  var toRemind = [];
  for (var i = 0; i < rows.length; i++) {

    // last notified will always be before now
    var last_notified = rows[i].last_notified;
    if (last_notified) {
      var lastNotifiedMoment = moment(parseFloat(last_notified));
      var timeSinceLastNotification = moment.duration(nowMoment.diff(lastNotifiedMoment)).asHours();
      //console.log(timeSinceLastNotification);

      // dont send a notification if the last one was sent within half an hour
      if (timeSinceLastNotification < 0.5) {
        continue;
      }
    }

    var remind_time = parseFloat(rows[i].remind_time);
    var repeat = parseFloat(rows[i].repeat);

    if (nowMoment.valueOf() < remind_time) {
      continue;
    }

    var remindMoment = moment(remind_time);
    var duration = moment.duration(nowMoment.diff(remindMoment));
    var numHoursNormalized = (duration.asHours() % repeat);

    if (buffer > numHoursNormalized && numHoursNormalized > 0) {
      toRemind.push(rows[i]);
    }
  }

  sendNotifications(toRemind, toRemind.length-1)

});

function sendNotifications(rows, index) {

  if (index == -1) {
    process.exit(1);
  }

  knex.select('subscription')
  .from('subscriptions')
  .where('uid', '=', rows[index].uid)
  .asCallback(function(err, subs) {
    if (err) console.log(err)

    var subscription = subs[0].subscription;

    // subscription.endpoint
    // subscription.keys

    // This is the same output of calling JSON.stringify on a PushSubscription
    let pushSubscription = {
      endpoint: subscription.endpoint,
      keys: subscription.keys
    };
    let payloadMessage = '{"msg" : "Take your '+rows[index].med_name+'"}';

    webpush.sendNotification(pushSubscription, payloadMessage);

    knex('medications')
    .where('mid', '=', rows[index].mid)
    .update({
      last_notified: nowMoment.valueOf()
    })
    .then(function (result) {
      console.log(currentTimeString + "   -----   " + "notification sent to uid:" + rows[index].uid + " for medication:"+ rows[index].mid);
      sendNotifications(rows, index-1);
    })
  });

}
